#!/usr/bin/env python3
import argparse
import hashlib
import json
import subprocess
import sys
import time
from pathlib import Path

try:
    import tomllib
except ModuleNotFoundError:
    print("Python 3.11+ required (tomllib stdlib).", file=sys.stderr)
    sys.exit(2)

REPO = Path(__file__).resolve().parents[1]
MANIFEST = REPO / "MANIFEST_CLONE.json"


# ---------------------- helpers ----------------------

def run(cmd, *, check=True, capture=False):
    kwargs = {"check": check}
    if capture:
        kwargs["stdout"] = subprocess.PIPE
        kwargs["stderr"] = subprocess.PIPE
    return subprocess.run(cmd, **kwargs)


def git(*args, capture=False, check=True):
    return run(["git", "-C", str(REPO), *args], check=check, capture=capture)


def working_tree_state() -> str:
    return git("status", "--porcelain", capture=True).stdout.decode()


def auto_commit_dirty_tree() -> bool:
    state = working_tree_state()
    if not state.strip():
        return False
    print("[clone] Auto-committing dirty working tree before sync.")
    git("add", "-A")
    if git("diff", "--cached", "--quiet", check=False).returncode == 0:
        print("[clone] Nothing staged after auto-commit attempt; continuing.")
        return False
    timestamp = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    git("commit", "-m", f"clone(pre-sync): auto-commit dirty tree {timestamp}")
    return True


def ensure_repo_clean(force: bool, auto_commit_enabled: bool) -> bool:
    auto_committed = False
    state = working_tree_state()
    if not state.strip():
        return auto_committed
    if auto_commit_enabled:
        auto_committed = auto_commit_dirty_tree()
        state = working_tree_state()
        if not state.strip():
            return auto_committed
        if force:
            print("[clone] Warning: tree still dirty after auto-commit; proceeding because --force was supplied.", file=sys.stderr)
            return auto_committed
        print("Working tree remains dirty after auto-commit. Resolve manually or rerun with --force.", file=sys.stderr)
        sys.exit(2)
    else:
        if force:
            print("[clone] Proceeding with dirty tree (auto-commit disabled).", file=sys.stderr)
            return auto_committed
        print("Working tree is dirty. Commit or stash unrelated edits first, or use --force.", file=sys.stderr)
        sys.exit(2)
    return auto_committed


def rsync_copy(src: Path, dest: Path, excludes, *, dry_run: bool, size_cap_mb, delete: bool) -> subprocess.CompletedProcess:
    args = [
        "rsync",
        "-a",
        "--no-perms",
        "--no-owner",
        "--no-group",
        "--prune-empty-dirs",
    ]
    if dry_run:
        args.append("-n")
    if size_cap_mb and size_cap_mb > 0:
        args.extend(["--max-size", f"{int(size_cap_mb)}m"])
    for pattern in excludes:
        args.extend(["--exclude", pattern])

    if src.is_dir():
        src_arg = str(src) + ("/" if not str(src).endswith("/") else "")
        dest.mkdir(parents=True, exist_ok=True)
        dest_arg = str(dest) + ("/" if not str(dest).endswith("/") else "")
        if delete:
            args.append("--delete")
    else:
        dest.parent.mkdir(parents=True, exist_ok=True)
        src_arg = str(src)
        dest_arg = str(dest)
        # deleting doesn't make sense for single files

    args.extend([src_arg, dest_arg])
    return run(args, capture=True)


def enforce_repo_relative(path: Path) -> Path:
    try:
        rel = path.relative_to(REPO)
    except ValueError:
        print(f"Configured destination {path} escapes repository root {REPO}", file=sys.stderr)
        sys.exit(2)
    return rel


def build_manifest(dest_paths):
    records = []
    seen = set()
    for dest in dest_paths:
        if dest.is_dir():
            for file_path in sorted(dest.rglob("*")):
                if not file_path.is_file():
                    continue
                rel = file_path.relative_to(REPO)
                if rel in seen:
                    continue
                seen.add(rel)
                h = hashlib.sha256()
                with file_path.open("rb") as fh:
                    for chunk in iter(lambda: fh.read(1024 * 1024), b""):
                        h.update(chunk)
                records.append(
                    {
                        "path": str(rel),
                        "sha256": h.hexdigest(),
                        "size": file_path.stat().st_size,
                    }
                )
        elif dest.exists():
            rel = dest.relative_to(REPO)
            if rel not in seen and dest.is_file():
                seen.add(rel)
                h = hashlib.sha256(dest.read_bytes()).hexdigest()
                records.append(
                    {
                        "path": str(rel),
                        "sha256": h,
                        "size": dest.stat().st_size,
                    }
                )
    return {
        "generated_at": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "files": records,
    }


# ---------------------- main ----------------------

def main():
    parser = argparse.ArgumentParser(description="Reconcile local trading-system files into the repository and push.")
    parser.add_argument("--dry-run", action="store_true", help="Analyze only; no writes or commits")
    parser.add_argument("--push", action="store_true", help="Push after committing (default if not --no-push)")
    parser.add_argument("--no-push", action="store_true", help="Do not push even if a commit is made")
    parser.add_argument("--rebase", action="store_true", help="git fetch && rebase origin/<branch> before syncing")
    parser.add_argument("--pr", action="store_true", help="Commit to sync/review-<timestamp> branch instead of main")
    parser.add_argument("--allow-large", action="store_true", help="Disable size cap on rsync")
    parser.add_argument("--scan-secrets", action="store_true", help="grep for potential secrets before committing")
    parser.add_argument("--force", action="store_true", help="Proceed even if the tree stays dirty after safeguards")
    parser.add_argument("--no-auto-commit", action="store_true", help="Skip the pre-sync auto-commit of a dirty tree")
    args = parser.parse_args()

    cfg_path = REPO / ".clone.toml"
    if not cfg_path.exists():
        print(f"Config missing: {cfg_path}", file=sys.stderr)
        sys.exit(2)

    config = tomllib.loads(cfg_path.read_text(encoding="utf-8"))
    global_cfg = config.get("global", {})
    branch = global_cfg.get("branch", "main")
    delete_on_repo = bool(global_cfg.get("delete_on_repo", True))
    write_manifest = bool(global_cfg.get("write_manifest", False))
    size_cap = None if args.allow_large else global_cfg.get("max_file_size_mb", 15)
    global_excludes = set(global_cfg.get("global_excludes", []))
    sources = config.get("source", [])
    if not sources:
        print("No [[source]] entries found in .clone.toml", file=sys.stderr)
        sys.exit(2)

    try:
        git("rev-parse", "--is-inside-work-tree")
    except subprocess.CalledProcessError:
        print(f"{REPO} is not a git repository", file=sys.stderr)
        sys.exit(2)

    if args.dry_run:
        auto_committed = ensure_repo_clean(force=True, auto_commit_enabled=False)
    else:
        auto_committed = ensure_repo_clean(force=args.force, auto_commit_enabled=not args.no_auto_commit)

    git("fetch", "origin", "--prune")
    if args.rebase:
        git("rebase", f"origin/{branch}")

    if args.pr:
        branch = f"sync/review-{time.strftime('%Y%m%d-%H%M%S')}"

    rsync_outputs = []
    dest_paths = []

    for src_cfg in sources:
        raw_path = src_cfg.get("path", "")
        source_path = Path(raw_path).expanduser().resolve()
        dest_rel = src_cfg.get("dest")
        optional = bool(src_cfg.get("optional", False))
        local_excludes = set(src_cfg.get("excludes", []))
        excludes = sorted(global_excludes | local_excludes)

        if not source_path.exists():
            if optional:
                continue
            print(f"Source missing: {source_path}", file=sys.stderr)
            sys.exit(2)

        if not dest_rel:
            dest_rel = source_path.name
        dest_path = (REPO / dest_rel).resolve()
        enforce_repo_relative(dest_path)

        result = rsync_copy(
            source_path,
            dest_path,
            excludes,
            dry_run=args.dry_run,
            size_cap_mb=size_cap,
            delete=delete_on_repo,
        )
        rsync_outputs.append(result.stdout.decode("utf-8", "ignore"))
        dest_paths.append(dest_path if source_path.is_dir() else dest_path)

    if args.dry_run:
        print("==== rsync dry-run summaries ====")
        for output in rsync_outputs:
            if output.strip():
                print(output.strip())
        print("==== end dry-run ====")
        sys.exit(0)

    if write_manifest:
        manifest = build_manifest(dest_paths)
        MANIFEST.write_text(json.dumps(manifest, indent=2), encoding="utf-8")

    git("add", "-A")
    if git("diff", "--cached", "--quiet", check=False).returncode == 0:
        print("No differences detected. Repo already mirrors local sources.")
        sys.exit(0)

    if args.scan_secrets:
        names = git("diff", "--cached", "--name-only", capture=True).stdout.decode().splitlines()
        suspect = []
        patterns = ["api[_-]?key", "secret", "password", "token", "AKIA[0-9A-Z]{16}"]
        for name in names:
            path = REPO / name
            if not path.is_file():
                continue
            try:
                text = path.read_text(errors="ignore")
            except Exception:
                continue
            for pat in patterns:
                if pat.lower() in text.lower():
                    suspect.append((name, pat))
                    break
        if suspect:
            print("Potential secrets detected in staged files:")
            for name, pat in suspect:
                print(f"  - {name} (matched pattern: {pat})")
            print("Aborting commit. Adjust excludes or remove sensitive files and retry.", file=sys.stderr)
            sys.exit(3)

    diff_stat = git("diff", "--cached", "--stat", capture=True).stdout.decode()
    commit_message = "clone(sync): reconcile repo with local sources\n\n" + diff_stat
    git("commit", "-m", commit_message)

    if args.pr:
        git("checkout", "-B", branch)

    if args.no_push:
        print("Committed locally (no push).")
        sys.exit(0)

    git("push", "-u", "origin", branch)
    print(f"Pushed to origin/{branch}")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("clone aborted by user.", file=sys.stderr)
        sys.exit(130)
